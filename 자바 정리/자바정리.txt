주석: 설명문, 컴파일 안됨,
// 한줄 주석
/*
    다중 주석//
*/

/*
	// 사용가능
	/* 사용하지 못한다 */
*/

** java.lang 패키지 안의 클래스는 import 할 필요가 없다.
    자동으로 import 된다.

** 이클립스 자바 실행 단축키 ctrl+F11

org.java.varable 패키지아래 VarEx1클래스를 생성 하시오, main매서드를 생성하고
콘솔에 "변수"를 출력해보세요.


1.변수
1) 하나의 데이터를 저장할 수 있는 메모리(저장) 공간
2) 변수는 두가지 의미가 있다. 1)주소 2) 주소의 참조값

== 변수 명명 규칙 ==
키워드(예약어)를 사용할 수 없다.
숫자로 시작하지 X
공백 허용 X
_$ 이외의 특수문자 X
대소문자 구분한다. -> Mysql,Oracle 대소문자X
소문자로 시작하자.
다른 문자가 시작되면 대문자로 시작하자.
한글은 사용 허지 말자


선언
초기화
할당


2. 상수
변하지 않는 값
1) 리터럴 상수: 그 값 자체
2) final 상수: 고정 데이터에 사용

==상수 명명 규칙==
대문자로만,
여러 단어로 구성된 이름의 경우 단어 사이에 '_'써서 구분함

3. 자바의 기본자료형(primitive types): 8가지
	1	2	4	8             
정수형 	byte	short	int	long
실수형			float	double
문자형		char
논리형	boolean

**char -> c언어에서는 1바이트, 

	1	2	4	8
정수형	byte	short	int	long
실수형			float	double
문자형		char
논리형	boolean

4. 자바의 참조형(객체형 object) = reference type
String, 배열, class, interface

*기본타입 변수는 값을 직접 대입
*참조타입 변수는 객체의 주소값을 대입(new)
*String: 문자열 객체 "", new String(" ");
*class: 객체를 설계하기 위한 설계도
*interface: 클래스에 도움이 되기 위한

*Scanner 클래스
- 읽은 바이트를 문자, 정수, 실수, 불린, 문자열 들 다양한 타입으로 변환하여 리턴
- 키보드에 연결된 System.in에게 키를 읽게 하고 원하는 타입으로 변환하여 리턴
- Scanner scn = new Scanner(System.in);
- scn.next();	문자열 입력 -> String url = scn.next(); // 띄어쓰기 전까지만 받음
- snc.nextlnt();	정수 입력 -> int num1 = scn.nextlnt();
- snc.nextLine();	문자열 입력(\n 포함)

*같은 자료형끼리의 연산 결과는 같은 자료형
- int*int = int
- double*double = double
- int*double = double: double형이 더 크므로 자동 형변환(auto casting)

*타입 변환과 자동 타입 변환
- 타입 변환: 한 타입의 값을 다른 타입의 값으로 변환
- 자동 타입 변환: 컴파일러에 의해 원래의 타입보다 큰 타입으로 자동 변환 double i=10+1.1;
		치환문(=)이나 수식 내에서 타입이 일치하지 않을 때


*int형 아래 연산 시 자동으로 int형으로 형변환 (short, byte, char, boolean)  byte(10)+10

*강제 형변환(명시적 형변환): 프로그래머가 강제로 함
- (변환될 자료형)data	ex) int i = 10;
			     byte b = (byte) i; -> 데이터 손실

ex) 	public static void main(String[] args) {
		
		System.out.println("형변환");
		//int형 아래 연산시 자동으로 int형으로 형변환 된다
		byte b1=10;
		byte b2=20;
		//byte + byte = int + int
		byte b3=(byte)(b1+b2);
		int i=b1+b2;
		System.out.println(i);
		//큰형 + 작은형 >> 큰형으로 자동으로 형변환
		int i2=10;
		double d=1.1;
		int i22=(int)(i2+d);
		//int i3= i2+d;//double + double
		double d2=i2+d;
		System.out.println(d2);
		
		int i3=i2+(int)d;
		int i4=(int)(i2+d);
		System.out.println(i3);
		System.out.println(i4);
		
		
	}

*연산자(operator): 연산기호
- 연산: 처리한다, 수행한다, 로직을 구현한다
1. 단항 연산자: 증감 연산자
2. 이항 연산자: 산술, 비교, 논리, 비트, 시프트, 대입(복합) 연산자
3. 삼항 연산자
*연산자 = operator
*패키지: 비슷한 기능의 클래스를 그룹화
- rt.jar 패키지에 java.util.Scanner 존재

*내가 new로 scn를 만들면 힙에 저장
- scn에 접근하는 연산자:.	ex) scn.next();

*연산자(operator): 연산의 기호, 연산의 매개
*연산: 처리, 실행, 구현....
*피연산자(operand): 연산의 대상 = 항
1. 단항 연산자: 항 하나 	ex) i++; ++i;	증감 연산자
2. 이항 연산자: 항 둘 ex) + - * / %		산술 연산자
			> >= < <= == !=	비교 연산자
			= += -= /= *= %= 대입(복합대입) 연산자
			&& || ^!		논리 연산자
			& | ^ ~		비트 연산자
			<< >>		시프트 연산자

3. 삼항 연산자: 항 셋ex) ? :		


1)산술연산자 + - * / %

/ -> 나누기
% -> 나머지

2) 비교 연산자 "왼쪽" , true, false, 조건문과 많이 사용
> 크다, 초과	5>10
>= 크거나 같다, 이상	5>=2
< 작다, 미만
<= 작거나 같다
== 같으냐?
!= 같지 않느냐?

객체==객체
  : 주소값을 비교한다.

객체.equal(객체)
  :대상의 내용을 비교한다. 

3) 논리 연산자 && || ^ ! , T(True), F(False)
&& 모든 조건이 true 일 때만 결과 값이 true

조건1	&&	조건2	결과
T		T	T
T		F	F
F		T	F
F		F	F

|| 조건이 하나이상 true이면 결과 값이 true
조건1	||	조건2	결과
T		T	T
T		F	T
F		T	T
F		F	F

! 부정 연산자(toggle형)
!false = ture		!true = false

^(XOR): 서로 다르면 true

조건1	^	조건2	결과
T		T	F
T		F	T
F		T	T
F		F	F	

4)부정 연산자 ! (toggle, 스위치)

5) 대입연산 -> 오른쪽의 연산의 결과를 왼쪽 변수에 대입, 연산의 마지막에 설정
int i=50+100-10;

복합 대입 연산자
int num1 = 100;
num1=num1+100
+=
num1+=100;

num1=num1-100;
-=
num1-=100;

num1=num1*100;
*=
num1*100;

num1=num1/100;
/=
num1/=100;

num1=num1%100;
%=
num1%=100;

6) 비트연산자 0 1	& | ~
&

- 1, 1일 때만 결과 1
ex) 10 -> 1010
  & 12 -> 1100 = 1000 -> 8

  20	10100
&30	11110
	= 10100

- 1이 하나라도 있으면 결과 1
ex) 10 -> 1010
  |   12 -> 1100 = 1110 -> 14

~(not) ~ ~0 ~1
~10


 20	10100
| 30	11110
	
	=11110

7) << >> 쉬프트 연산자
10 ~ 1010
오른쪽 쉬프트 연산자 -> 작아진다. 소수점 아래 숫자 삭제
10  >>2  10.10
왼쪽 쉬프트 연산자 -> 커진다. 빈공간은 0으로 채워진다.
10 <<2 101000.







******
static
Wrapper클래스
박싱,언박싱

** 단항연산자(증감 연산자)**

- 반복문과 같이 많이 사용
 i++; // 선처리 후증가
 ++i; // 선증가 후처리
 i--; // 선처리 후감소
 --i; // 선감소 후처리

********for문은 선처리나 선증가나 똑같이 나옴*******


*삼항 연산자: 조건식? true: false;
// 조건식의 결과 값이 길지 않을때 사용
조건식 ? 조건이 true: 조건이 ture아닐때;

if~ else~;

*******아스키 코드********

1. 미국정보교환표준부호(American Standard Code for Information Interchange). 또는 줄여서 ASCII(아스키)는 영문 알파벳을
사용하는 대표적인 문자 인코딩이다. 아스키는 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며, 대부분의 문자 인코딩이
아스키에 기초를 두고 있다.

2. 아스키는 7비트 인코딩으로, 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어 진다. 제어 문자들은
역사적인 이유로 남아 있으며 대부분은 더 이상 사용되지 않는다, 출력 가능한 문자들은 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수문자
그리고 하나의 공백 문자로 이루어진다.

*****************************

10진수	문자
int	char
0
...
65	A
66	B
...

97	a
98	b
...
'B'-'A'

*******아스키 코드 역사*****
아스키 코드는 지금의 미국 국가표준 협회(ANSI)의 전신인 미국 표준 협회 (ASA)가 주도한 X3 위원회가 개발했다.
그 아래의 x3.2 소위원회는 1960년 10월 6일 아스키 표준화 작업을 시작하여, 1963년 표준화 초한을 발간했고, 1967년 개정했으며,
가장 최근의 업데이트는 1986년에 있었다.

*조건문 -> condition
- 조건식과 블록{}으로 이루어져 있다
- if문과 swich문
- 모든 swich문은 if문으로 변경가능
- 모든 if문은 swich문으로 변경 할수 있지 않다

조건1
조건 하나 일때 "조건이 true일 때만 실행",
조건이 false면 {} 실행(처리)를 안한다

if(조건){
	처리문;//조건이 true
}

if(조건) 처리문;

if(조건) 
	처리문;



조건2
조건이 여러개 일때
if(조건1){
	조건1 처리문;
}else if(조건2){
	조건2 처리문;
}else if(조건3){
	조건3 처리문;
}else if(조건4){
	조건4 처리문;
}else if(조건5){
	조건5 처리문;
}
* switch ~ case
"모든 switch문은 if문으로 변환 가능"
"모든 if문은 switch문으로 변환 가능 하지 않다"
조건의 키값이 정수형(1,A,), 범위는 제한적이다
int key=3;

switch(key){
	case 1:
		처리문(1);
		break;
	case 2:
		처리문(2);
		break;
	case 3:
		처리문(3);
		break;
	default:
		나머지처리문;
}

*참조타입(reference type)
- 생성된 객체의 주소값을 대입
- 객체.멤버 로 접근

*배열
1. 같은 type의 data를 순서대로 그룹화
2. 인덱스(번지, 요소)는 0부터 시작
3. 배열의 개수는 고정한다 - 컬렉션...고정X
4. 배열 참조형 타입(배열의 전체 주소값으로 접근) - new 배열
5. 배열은 생성과 동시에 초기화해야 한다.
6. 값을 초기화하지 않으면 0으로 초기화 한다.
7. 반복문(for)과 같이 자주 사용
8. 전체 배열의 데이터의 개수는 전체 인덱스 총 수 보다 1크다.
9. 배열 이름에 전체 배열의 주소값을 저장
10. for~in: DB의 데이터를 가져올 때

*클래스
- 사용자 정의 타입 	ex) DBMemberDto member;
- 객체를 설계하기 위한 설계도(틀)

*객체
- 클래스를 통해 만들어진 현실 사물체
- 현실 세계의 모든 것을 나타냄


form -> 사용자의 입력 정보 서버에 전송
<form action="전송될 서버주소" method="">
<input name="">
</form>	

git

node.js 설치 -> 자바스크립트 서버사이드 라이브러리
git 설치 -> 최신버전
github 계정 생성
-> Repository 생성(저장소)

node.js 설치 확인 node --version
기본 cmd		git version
MIT라이선스

echo "# javaStudy" >> README.md
git init

두번째 이후

git add README.md -> git add . (모든 파일을 업로드)
git commit -m "first commit" -> commit "실행 직전이다"
git branch -M main
git remote add origin https://github.com/jan9141/javaStudy.git
git push -u origin master


두번째 이후

git add README.md -> git add . (모든 파일을 업로드)
git commit -m "first commit" -> commit "실행 직전이다"
git push -u origin master


원도우 터미널
source tree -> git tool

remote -> github

원도우 명령

dir 현재 디렉토리 구조
cd ~ 디렉토리 이동
mkdir 디렉토리 생성
cls  지우기

cd 디렉토리

git config --global user.name"이름"
git config --global user.email 이메일@gmail.com

\\192.168.23.130		
WAS -> tomcat
****이클립스***
ctrl + F 찾아서 바꾼다
***다른 도구****
ctrl + H ->찾아서 바꾼다
ctrl + F -> 찾는다.

